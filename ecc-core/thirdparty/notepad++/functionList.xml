<?xml version="1.0" encoding="UTF-8" ?>
<!-- ==========================================================================\
|
|   To learn how to make your own language parser, please check the following
|   link:
|       http://notepad-plus-plus.org/features/function-list.html
|
\=========================================================================== -->
<NotepadPlus>
	<functionList>
		<associationMap>
		<!--
			langID:

			Don't use L_JS (19) use L_JAVASCRIPT (58) instead!
			Don't use L_USER and L_EXTERNAL, use extension or UDL name association instead!

			L_ADA          = 42 | L_DIFF         = 33 | L_LISP         = 30 | L_SCHEME       = 31
			L_ASCII        = 14 | L_EXTERNAL     = 60 | L_LUA          = 23 | L_SEARCHRESULT = 47
			L_ASM          = 32 | L_FLASH        = 27 | L_MAKEFILE     = 10 | L_SMALLTALK    = 37
			L_ASP          = 16 | L_FORTRAN      = 25 | L_MATLAB       = 44 | L_SQL          = 17
			L_AU3          = 40 | L_FORTRAN_77   = 59 | L_NSIS         = 28 | L_TCL          = 29
			L_BASH         = 26 | L_GUI4CLI      = 51 | L_OBJC         =  5 | L_TEX          = 24
			L_BATCH        = 12 | L_HASKELL      = 45 | L_PASCAL       = 11 | L_TEXT         =  0
			L_C            =  2 | L_HTML         =  8 | L_PERL         = 21 | L_USER         = 15
			L_CAML         = 41 | L_INI          = 13 | L_PHP          =  1 | L_VB           = 18
			L_CMAKE        = 48 | L_INNO         = 46 | L_POWERSHELL   = 53 | L_VERILOG      = 43
			L_COBOL        = 50 | L_JAVA         =  6 | L_PROPS        = 34 | L_VHDL         = 38
			L_COFFEESCRIPT = 56 | L_JAVASCRIPT   = 58 | L_PS           = 35 | L_XML          =  9
			L_CPP          =  3 | L_JS           = 19 | L_PYTHON       = 22 | L_YAML         = 49
			L_CS           =  4 | L_JSON         = 57 | L_R            = 54 |
			L_CSS          = 20 | L_JSP          = 55 | L_RC           =  7 |
			L_D            = 52 | L_KIX          = 39 | L_RUBY         = 36 |

			 0 = L_TEXT         | 16 = L_ASP          | 32 = L_ASM          | 48 = L_CMAKE
			 1 = L_PHP          | 17 = L_SQL          | 33 = L_DIFF         | 49 = L_YAML
			 2 = L_C            | 18 = L_VB           | 34 = L_PROPS        | 50 = L_COBOL
			 3 = L_CPP          | 19 = L_JS           | 35 = L_PS           | 51 = L_GUI4CLI
			 4 = L_CS           | 20 = L_CSS          | 36 = L_RUBY         | 52 = L_D
			 5 = L_OBJC         | 21 = L_PERL         | 37 = L_SMALLTALK    | 53 = L_POWERSHELL
			 6 = L_JAVA         | 22 = L_PYTHON       | 38 = L_VHDL         | 54 = L_R
			 7 = L_RC           | 23 = L_LUA          | 39 = L_KIX          | 55 = L_JSP
			 8 = L_HTML         | 24 = L_TEX          | 40 = L_AU3          | 56 = L_COFFEESCRIPT
			 9 = L_XML          | 25 = L_FORTRAN      | 41 = L_CAML         | 57 = L_JSON
			10 = L_MAKEFILE     | 26 = L_BASH         | 42 = L_ADA          | 58 = L_JAVASCRIPT
			11 = L_PASCAL       | 27 = L_FLASH        | 43 = L_VERILOG      | 59 = L_FORTRAN_77
			12 = L_BATCH        | 28 = L_NSIS         | 44 = L_MATLAB       | 60 = L_EXTERNAL
			13 = L_INI          | 29 = L_TCL          | 45 = L_HASKELL      |
			14 = L_ASCII        | 30 = L_LISP         | 46 = L_INNO         |
			15 = L_USER         | 31 = L_SCHEME       | 47 = L_SEARCHRESULT |

			if langID cannot be found above, you can set the file extensions ...

			<association id="my_parser_id" ext=".my_parser_ext1" />
			<association id="my_parser_id" ext=".my_parser_ext2" />

			and for User Defined Languages (UDL's) use ...

			<association id="my_parser_id" userDefinedLangName="My UDL Name" />


			Note(s):
				Not required, just a guide.
				Suffix		Indicates
				~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				_class		parser has a class part only
				_function	parser has a function part only
				_syntax		parser has both a class and function part
		-->
			<!-- ======================================================================== -->
			<!--         ___ parserID                                                     -->
			<!--         V                                                                -->
			<association id=         "php_syntax"     langID= "1"                          />
			<association id=           "c_function"   langID= "2"                          />
			<association id=   "cplusplus_syntax"     langID= "3"                          />
			<association id=      "csharp_class"      langID= "4"                          />
			<association id=        "java_syntax"     langID= "6"                          />
			<association id=         "xml_node"       langID= "9"                          />
			<association id=       "batch_label"      langID="12"                          />
			<association id=         "ini_section"    langID="13"                          />
			<association id=        "perl_function"   langID="21"                          />
			<association id=      "python_syntax"     langID="22"                          />
			<association id=        "bash_function"   langID="26"                          />
			<association id=        "nsis_syntax"     langID="28"                          />
			<association id=    "assembly_subroutine" langID="32"                          />
			<association id=        "ruby_syntax"     langID="36"                          />
			<association id=     "autoit3_function"   langID="40"                          />
			<association id=   "innosetup_syntax"     langID="46"                          />
			<association id=  "powershell_function"   langID="53"                          />
			<association id=  "javascript_function"   langID="58"                          />
			<!-- ======================================================================== -->
			<association id=       "baanc_section"    langID="60"                          />
			<!-- ======================================================================== -->
			<association id=         "krl_function"   userDefinedLangName="KRL"            />
			<association id=         "krl_function"   ext=".src"                           />
			<association id=         "krl_function"   ext=".sub"                           />
			<!-- ======================================================================== -->
			<association id=   "sinumerik_function"   userDefinedLangName="Sinumerik"      />
			<association id=   "sinumerik_function"   ext=".arc"                           />
			<!-- ======================================================================== -->
			<association id=    "universe_basic"      userDefinedLangName="UniVerse BASIC" />
			<association id=    "universe_basic"      ext=".bas"                           />
			<!-- ======================================================================== -->
		</associationMap>
		<parsers>

			<!-- ========================================================= [ PHP ] -->
			<!-- PHP - Personal Home Page / PHP Hypertext Preprocessor             -->

			<parser
				id         ="php_syntax"
				displayName="PHP"
				commentExpr="(?s:/\*.*?\*/)|(?m-s://.*?$)"
			>
				<classRange
					mainExpr    ="^\s*(class|abstract\s+class|final\s+class|interface|trait)[\t\x20]+[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*(\s*|\s*(extends|implements|(extends\s+(\\|[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*)+\s+implements))\s+(\,\s*|(\\|[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*))+\s*)?\{"
					openSymbole ="\{"
					closeSymbole="\}"
				>
					<className>
						<nameExpr expr="(class|abstract\s+class|final\s+class|interface|trait)\s+\w+" />
						<nameExpr expr="\s+\w+\Z" />
						<nameExpr expr="\w+\Z" />
					</className>
					<function
						mainExpr="^\s*((static|public|protected|private|final)*(\s+(static|public|protected|private|final))+\s+)?(function\s+)+(\w+(\s+\w+)?(\s+|\*\s+|\s+\*|\s+\*\s+))?(\w+\s*::)?(?!(if|while|for|switch))[\w~]+\s*\([^\{]*\{"
					>
						<functionName>
							<funcNameExpr expr="(?!(if|while|for|switch))\w+\s*\([^\{]*" />
							<!-- comment out the following node to display the method with parameters -->
							<funcNameExpr expr="(?!(if|while|for|switch))\w+" />
						</functionName>
					</function>
				</classRange>
				<function
					mainExpr="^\s*function\s+\w+\s*\("
				>
					<functionName>
						<nameExpr expr="(?!(if|while|for))\w+\s*\(" />
						<nameExpr expr="(?!(if|while|for))\w+" />
					</functionName>
					<className>
						<nameExpr expr="\w+(?=\s*::)" />
					</className>
				</function>
			</parser>

			<!-- =========================================================== [ C ] -->

			<parser
				displayName="C"
				id         ="c_function"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?s:\x2F\x2A.*?\x2A\x2F)                        # Multi Line Comment
							|	(?m-s:\x2F{2}.*$)                               # Single Line Comment
							|	(?s:\x22(?:[^\x22\x5C]|\x5C.)*\x22)             # String Literal - Double Quoted
							|	(?s:\x27(?:[^\x27\x5C]|\x5C.)*\x27)             # String Literal - Single Quoted
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?:                                                 # Declaration specifiers
								\b
								(?:
									(?-i:auto|register|static|extern|typedef)   # Storage class specifier
								|	(?:                                         # Type specifier
										(?-i:void|char|short|int|long|float|double|(?:un)?signed)
									|	(?-i:struct|union|enum)
										\s+
										(?&amp;VALID_ID)                        # Struct, Union or Enum Specifier (simplified)
									|	(?&amp;VALID_ID)                        # Type-definition name
									)
								|	(?'TYPE_QUALIFIER'(?-i:const|volatile))
								)
								\b
								\s*
							)*
							(?'DECLARATOR'
								(?'POINTER'
									\*
									\s*
									(?:
										\b(?&amp;TYPE_QUALIFIER)\b
										\s*
									)*
									(?:(?&amp;POINTER))?                        # Boost::Regex 1.58-1.59 do not correctly handle quantifiers on subroutine calls
								)?
								(?:                                             # 'DIRECT_DECLARATOR'
									\s*
									(?'VALID_ID'                                # valid identifier, use as subroutine
										\b(?!(?-i:
											auto
										|	break
										|	c(?:ase|har|on(?:st|ntinue))
										|	d(?:efault|o(?:uble)?)
										|	e(?:lse|num|xtern)
										|	f(?:loat|or)
										|	goto
										|	i(?:f|n(?:t|line))
										|	long
										|	while
										|	re(?:gister|strict|turn)
										|	s(?:hort|i(?:gned|zeof)|t(?:atic|ruct)|witch)
										|	typedef
										|	un(?:ion|signed)
										|	vo(?:id|latile)
										|	_(?:
												A(?:lignas|lignof|tomic)
											|	Bool
											|	Complex
											|	Generic
											|	Imaginary
											|	Noreturn
											|	Static_assert
											|	Thread_local
											)
										)\b)                                    # keywords, not to be used as identifier
										[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*        # valid character combination for identifiers
									)
								|	\s*\(
									(?&amp;DECLARATOR)
									\)
								|	\s*(?&amp;VALID_ID)
									\s*\[
									[^[\];{]*?
									\]
								|	\s*(?&amp;VALID_ID)
									\s*\(
									[^();{]*?
									\)
								)
								\s*
							)
							(?=\{)                                              # start of function body
						"
				>
					<functionName>
						<nameExpr expr="(?x)                                    # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*
								\s*\(                                           # start of parameters
								(?s:.*?)                                        # whatever, until...
								\)                                              # end   of parameters
							" />
						<!-- comment out the following node to display the method with its parameters -->
<!--						<nameExpr expr="[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*" /> -->
					</functionName>
				</function>
			</parser>

			<!-- ========================================================= [ C++ ] -->

			<parser
				displayName="C++"
				id         ="cplusplus_syntax"
				commentExpr="(?s:/\*.*?\*/)|(?m-s://.*?$)"
			>
				<classRange
					mainExpr    ="^[\t\x20]*(class|struct)[\t\x20]+\w+\s*(final)?\s*(:\s*(public|protected|private)\s+\w+\s*)?\{"
					openSymbole ="\{"
					closeSymbole="\}"
				>
					<className>
						<nameExpr expr="(class|struct)[\t\x20]+\w+" />
						<nameExpr expr="[\t\x20]+\w+" />
						<nameExpr expr="\w+" />
					</className>
					<function
						mainExpr="^[\t\x20]*((static|const|virtual)\s+)?(\w+(\s+\w+)?(\s+|(\*|\*\*|&amp;)\s+|\s+(\*|\*\*|&amp;)|\s+(\*|\*\*|&amp;)\s+))?(\w+\s*::)?(?!(if|while|for|switch))[\w~]+\s*\([^\)\(]*\)(\s*const\s*)?(\s*(final|override|final\s*override|override\s*final)\s*)?[\n\s]*\{"
					>
						<functionName>
							<funcNameExpr expr="(?!(if|while|for|switch))[\w~]+\s*\(" />
							<funcNameExpr expr="(?!(if|while|for|switch))[\w~]+" />
						</functionName>
					</function>
				</classRange>
				<function
					mainExpr="^[\t\x20]*((static|const|virtual)\s+)?\w+(\s+\w+)?(\s+|(\*|\*\*|&amp;)\s+|\s+(\*|\*\*|&amp;)|\s+(\*|\*\*|&amp;)\s+)(\w+\s*::)?(?!(if|while|for))\w+\s*\([^\)\(]*\)(\s*const\s*)?[\n\s]*\{"
				>
					<functionName>
						<nameExpr expr="(?!(if|while|for))\w+\s*\(" />
						<nameExpr expr="(?!(if|while|for))\w+" />
					</functionName>
					<className>
						<nameExpr expr="\w+(?=\s*::)" />
					</className>
				</function>
			</parser>

			<!-- ========================================================== [ C# ] -->

			<!--
			|   Based on:
			|       http://sourceforge.net/p/notepad-plus/patches/613/
			\-->
			<parser
				displayName="C#"
				id         ="csharp_class"
				commentExpr="(?s:/\*.*?\*/)|(?m-s://.*?$)"
			>
				<classRange
					mainExpr    ="^[\t\x20]*((public|protected|private|internal)\s+)?(\w+\s*)?(class|struct|interface)[\t\x20]+[^\{]+\{"
					openSymbole ="\{"
					closeSymbole="\}"
				>
					<className>
						<nameExpr expr="(class|struct|interface)[\t\x20]+\w+" />
						<nameExpr expr="[\t\x20]+\w+" />
						<nameExpr expr="\w+" />
					</className>
					<function
						mainExpr="^[^\S\r\n]*(?&lt;modifier1&gt;(?:public|protected|internal|private)\s*)?(?&lt;modifier2&gt;(?:new|static|virtual|sealed|override|abstract|extern)\s*)?(partial\s*)?(?&lt;type&gt;(?!(return|if|else))\w+(?&lt;genericType&gt;&lt;[\w,\s&lt;&gt;]+&gt;)?\s+)(?&lt;name&gt;\w+(?&lt;genericNameType&gt;&lt;[\w,\s&lt;&gt;]+&gt;)?\s?)\((?&lt;params&gt;[\w\s,&lt;&gt;\[\]\:=\.]*)\)(?&lt;ctorChain&gt;\s*\:\s*(?:base|this)\s*\((?&lt;ctorParams&gt;[\w\s,&lt;&gt;\[\]\:=\.]*)\))?[\w\s&lt;&gt;\:,\(\)\[\]]*(?:\{|;)"
					>
						<functionName>
							<funcNameExpr expr="(\w+(&lt;[\w,\s&lt;&gt;]+&gt;)?\s?)\(" />
							<funcNameExpr expr="(\w+(&lt;[\w,\s&lt;&gt;]+&gt;)?\s?)" />
						</functionName>
					</function>
				</classRange>
			</parser>

			<!-- ======================================================== [ Java ] -->

			<!--
			|   Based on:
			|       https://notepad-plus-plus.org/community/topic/12691/function-list-with-java-problems
			\-->
			<parser
				displayName="Java"
				id         ="java_syntax"
			>
				<classRange
					mainExpr    ="(?x)                                          # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?m)^[\t\x20]*                                      # leading whitespace
							(?:
								(?-i:
									abstract
								|	final
								|	native
								|	p(?:rivate|rotected|ublic)
								|	s(?:tatic|trictfp|ynchronized)
								|	transient
								|	volatile
								|	@[A-Za-z_]\w*                               # qualified identifier
									(?:                                         # consecutive names...
										\.                                      # ...are dot separated
										[A-Za-z_]\w*
									)*
								)
								\s+
							)*
							(?-i:class|enum|@?interface)
							\s+
							(?'DECLARATOR'
								(?'VALID_ID'                                    # valid identifier, use as subroutine
									\b(?!(?-i:
										a(?:bstract|ssert)
									|	b(?:oolean|reak|yte)
									|	c(?:ase|atch|har|lass|on(?:st|tinue))
									|	d(?:efault|o(?:uble)?)
									|	e(?:lse|num|xtends)
									|	f(?:inal(?:ly)?|loat|or)
									|	goto
									|	i(?:f|mp(?:lements|ort)|nstanceof|nt(?:erface)?)
									|	long
									|	n(?:ative|ew)
									|	p(?:ackage|rivate|rotected|ublic)
									|	return
									|	s(?:hort|tatic|trictfp|uper|witch|ynchronized)
									|	th(?:is|rows?)|tr(?:ansient|y)
									|	vo(?:id|latile)
									|	while
									)\b)                                        # keywords, not to be used as identifier
									[A-Za-z_]\w*                                # valid character combination for identifiers
								)
								(?:
									\s*\x3C                                     # start-of-template indicator...
									(?'GENERIC'                                 # ...match first generic, use as subroutine
										\s*
										(?:
											(?&amp;DECLARATOR)                  # use named generic
										|	\?                                  # or unknown
										)
										(?:                                     # optional type extension
											\s+(?-i:extends|super)
											\s+(?&amp;DECLARATOR)
											(?:                                 # multiple bounds...
												\s+\x26                         # ...are ampersand separated
												\s+(?&amp;DECLARATOR)
											)*
										)?
										(?:                                     # match consecutive generics objects...
											\s*,                                # ...are comma separated
											(?&amp;GENERIC)
										)?
									)
									\s*\x3E                                     # end-of-template indicator
								)?
								(?:                                             # package and|or nested classes...
									\.                                          # ...are dot separated
									(?&amp;DECLARATOR)
								)?
							)
							(?:                                                 # optional object extension
								\s+(?-i:extends)
								\s+(?&amp;DECLARATOR)
								(?:                                             # consecutive objects...
									\s*,                                        # ...are comma separated
									\s*(?&amp;DECLARATOR)
								)*
							)?
							(?:                                                 # optional object implementation
								\s+(?-i:implements)
								\s+(?&amp;DECLARATOR)
								(?:                                             # consecutive objects...
									\s*,                                        # ...are comma separated
									\s*(?&amp;DECLARATOR)
								)*
							)?
							\s*\{                                               # whatever, up till start-of-body indicator
						"
					openSymbole ="\{"
					closeSymbole="\}"
				>
					<className>
						<nameExpr expr="(?-i:class|enum|@?interface)\s+\K\w+(?:\s*\x3C.*?\x3E)?" />
					</className>
					<function
						mainExpr="(?x)                                          # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								^[\t\x20]*                                      # leading whitespace
								(?:
									(?-i:
										abstract
									|	final
									|	native
									|	p(?:rivate|rotected|ublic)
									|	s(?:tatic|trictfp|ynchronized)
									|	transient
									|	volatile
									|	@[A-Za-z_]\w*                           # qualified identifier
										(?:                                     # consecutive names...
											\.                                  # ...are dot separated
											[A-Za-z_]\w*
										)*
									)
									\s+
								)*
								(?:
									\s*\x3C                                     # start-of-template indicator
									(?&amp;GENERIC)
									\s*\x3E                                     # end-of-template indicator
								)?
								\s*
								(?'DECLARATOR'
									[A-Za-z_]\w*                                # (parent) type name
									(?:                                         # consecutive sibling type names...
										\.                                      # ...are dot separated
										[A-Za-z_]\w*
									)*
									(?:
										\s*\x3C                                 # start-of-template indicator
										(?'GENERIC'                             # match first generic, use as subroutine
											\s*
											(?:
												(?&amp;DECLARATOR)              # use named generic
											|	\?                              # or unknown
											)
											(?:                                 # optional type extension
												\s+(?-i:extends|super)
												\s+(?&amp;DECLARATOR)
												(?:                             # multiple bounds...
													\s+\x26                     # ...are ampersand separated
													\s+(?&amp;DECLARATOR)
												)*
											)?
											(?:                                 # consecutive generics objects...
												\s*,                            # ...are comma separated
												(?&amp;GENERIC)
											)?
										)
										\s*\x3E                                 # end-of-template indicator
									)?
									(?:                                         # package and|or nested classes...
										\.                                      # ...are dot separated
										(?&amp;DECLARATOR)
									)?
									(?:                                         # optional compound type...
										\s*\[                                   # ...start-of-compound indicator
										\s*\]                                   # ...end-of-compound indicator
									)*
								)
								\s+
								(?'VALID_ID'                                    # valid identifier, use as subroutine
									\b(?!(?-i:
										a(?:bstract|ssert)
									|	b(?:oolean|reak|yte)
									|	c(?:ase|atch|har|lass|on(?:st|tinue))
									|	d(?:efault|o(?:uble)?)
									|	e(?:lse|num|xtends)
									|	f(?:inal(?:ly)?|loat|or)
									|	goto
									|	i(?:f|mp(?:lements|ort)|nstanceof|nt(?:erface)?)
									|	long
									|	n(?:ative|ew)
									|	p(?:ackage|rivate|rotected|ublic)
									|	return
									|	s(?:hort|tatic|trictfp|uper|witch|ynchronized)
									|	th(?:is|rows?)|tr(?:ansient|y)
									|	vo(?:id|latile)
									|	while
									)\b)                                        # keywords, not to be used as identifier
									[A-Za-z_]\w*                                # valid character combination for identifiers
								)
								\s*\(                                           # start-of-parameters indicator
								(?'PARAMETER'                                   # match first parameter, use as subroutine
									\s*(?-i:final\s+)?
									(?&amp;DECLARATOR)
									\s+(?&amp;VALID_ID)                         # parameter name
									(?:                                         # consecutive parameters...
										\s*,                                    # ...are comma separated
										(?&amp;PARAMETER)
									)?
								)?
								\)                                              # end-of-parameters indicator
								(?:                                             # optional exceptions
									\s*(?-i:throws)
									\s+(?&amp;VALID_ID)                         # first exception name
									(?:                                         # consecutive exception names...
										\s*,                                    # ...are comma separated
										\s*(?&amp;VALID_ID)
									)*
								)?
								[^{;]*\{                                        # start-of-function-body indicator
							"
					>
						<functionName>
							<funcNameExpr expr="\w+(?=\s*\()" />
						</functionName>
					</function>
				</classRange>
			</parser>

			<!-- ========================================================= [ XML ] -->
			<!-- XML - eXtensible Markup Language                                  -->

			<parser
				displayName="XML Node"
				id         ="xml_node"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?:\x3C!--(?:[^\-]|-(?!-\x3E))*--\x3E)          # Multi Line Comment
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							\x3C                                                # begin of node
							(?:
								(?-i:\?XML)                                     # only name of root node is allowed to start with a question mark
							|	\w+(?::\w+)?                                    # a node name can contain a colon e.g. `xs:schema`
							)
							(?:                                                 # match attributes
								\s+                                             # at least one whitespace before attribute-name
								\w+(?::\w+)?                                    # an attribute name can contain a colon e.g. `xmlns:xs`
								\h*=\h*                                         # name-value separator can be surrounded by blanks
								(?:                                             # quoted attribute value, embedded escaped quotes allowed...
									\x22(?:[^\x22\x5C]|\x5C.)*?\x22             # ...double quoted...
								|	\x27(?:[^\x27\x5C]|\x5C.)*?\x27             # ...single quoted
								)
							)+                                                  # only match nodes with at least one attribute
						"
				>
					<functionName>
						<nameExpr expr="[^\x3C]*" />
					</functionName>
				</function>
			</parser>
			
			<!-- ================================ [ Batch / Command Shell Script ] -->

			<parser
				displayName="Batch / Command Shell Script"
				id         ="batch_label"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?m-s:(?i:REM)(?:\h.+)?$)                       # Single Line Comment 1
							|	(?m-s::{2}.*$)                                  # Single Line Comment 2
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?m-s)                                              # enforce strict line by line search
							^                                                   # label starts at the beginning of a line,...
							\h*                                                 # ...can be preceded by blank characters and
							:                                                   # ...starts with a colon
							\K                                                  # keep the text matched so far, out of the overall match
							\w                                                  # a label name has to start with a word character,...
							[\w.\-]+                                            # ...the remainder of the name can contain dots and minus signs and
							\b                                                  # ...ends at a word boundary i.e. discard any trailing characters
						"
				/>
			</parser>

			<!-- ========================================= [ Initialisation File ] -->
			<!-- File format used for: .INF / .INI / .REG / .editorconfig          -->

			<parser
				displayName="INI Section"
				id         ="ini_section"
				commentExpr="(?x)
								(?m-s:[;\#].*$)                                 # Single Line Comment
							"
			>
				<function
					mainExpr="^\h*[\[&quot;][\w*.;\x20()\-]+[&quot;\]]"
				>
					<functionName>
						<nameExpr expr="[^[\]&quot;]*" />
					</functionName>
				</function>
			</parser>

			<!-- ======================================================== [ PERL ] -->
			<!-- PERL - Practical Extraction and Reporting Language                -->

			<parser
				displayName="PERL"
				id         ="perl_function"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?m-s:\x23.*$)                                  # Single Line Comment
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							sub
							\s+
							[A-Za-z_]\w*
							\s*
							\(
							[^()]*
							\)
							\s*\{                                               # start of class body
						"
				>
					<functionName>
						<nameExpr expr="(?:sub\s+)?\K[A-Za-z_]\w*" />
					</functionName>
					<className>
						<nameExpr expr="[A-Za-z_]\w*(?=\s*:{2})" />
					</className>
				</function>
			</parser>

			<!-- ====================================================== [ Python ] -->

			<parser
				displayName="Python"
				id         ="python_syntax"
				commentExpr="(?s:'''.*?''')|(?m-s:#.*?$)"
			>
				<classRange
					mainExpr    ="(?&lt;=^class\x20).*?(?=\n\S|\Z)"
				>
					<className>
						<nameExpr expr="\w+(?=[\(|:])" />
					</className>
					<function
						mainExpr="(?&lt;=def\x20).+?(?=:)"
					>
						<functionName>
							<funcNameExpr expr=".*" />
						</functionName>
					</function>
				</classRange>
				<function
					mainExpr="(?&lt;=def\x20).+?(?=:)"
				>
					<functionName>
						<nameExpr expr=".*" />
					</functionName>
				</function>
			</parser>

			<!-- ======================================================== [ Bash ] -->
			<!-- BASH - Bourne-Again Shell                                         -->

			<parser
				displayName="Bash"
				id         ="bash_function"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?-s:(?:^\x23[^!]|^\h*\x23|\h+\x23).*$)         # Single Line Comment
							|	(?s:\x22(?:[^\x22\x5C]|\x5C.)*\x22)             # String Literal - Double Quoted
							|	(?s:\x27[^\x27]*\x27)                           # String Literal - Single Quoted
							|	(?s:                                            # Here Document (Type 1) and Here String
									\x3C{2,3}\h*(?'HD1ID'[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*\b)[^\r\n]*\R
									(?s:.*?)
									\R\k'HD1ID'                                 # close with exactly the same identifier, in the first column
								)
							|	(?s:                                            # Here Document (Type 2)
									\x3C{2}-\h*(?'HD2ID'[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*\b)[^\r\n]*\R
									(?s:.*?)
									\R\h*\k'HD2ID'                              # close with exactly the same identifier
								)
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?m)^\h*                                            # optional leading whitespace
							(?:
								(?-i:function\s+)
								(?'VALID_ID'                                    # valid identifier, use as subroutine
									\b(?!(?-i:
										do(?:ne)?
									|	el(?:if|se)|esac
									|	f(?:i|or|unction)
									|	i[fn]
									|	select
									|	t(?:hen|ime)
									|	until
									|	while
									)\b)                                        # keywords, not to be used as identifier
									[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*            # valid character combination for identifiers
								)
								(?:\s*\([^)]*?\))?                              # parentheses and parameters optional
							|
								(?&amp;VALID_ID)
								\s*\([^)]*?\)                                   # parentheses required, parameters optional
							)
							[^{;]*?\{                                           # no semi-colon until start of body
						"
				>
					<functionName>
						<nameExpr expr="\b(?!function\b)\w+(?:\s*\([^)]*\))?" />
						<!-- comment out the following node to display the function with its parameters -->
						<nameExpr expr="\w+(?=\b)" />
					</functionName>
				</function>
			</parser>

			<!-- ======================================================== [ NSIS ] -->
			<!-- NSIS - Nullsoft Scriptable Install System                         -->

			<parser
				displayName="NSIS"
				id         ="nsis_syntax"
			>
				<classRange
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							\b(?-i:SectionGroup)\b                              # open indicator
							(?s:.*?)
							\b(?-i:SectionGroupEnd)\b                           # close indicator
						"
				>
					<className>
						<nameExpr expr="(?x)                                    # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?m-s)
								SectionGroup\h+(?-i:/e\h+)?                     # start indicator and its optional switch
								\K                                              # keep the text matched so far, out of the overall match
								.+$                                             # whatever, till end-of-line
							"
						/>
						<nameExpr expr="[^\r\n\x22]*" />
					</className>
					<function
						mainExpr="(?x)                                          # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?m)
								^(?'INDENT'\h*)                                 # optional leading whitespace at start-of-line
								(?:
									(?-i:!macro)
									\h+                                         # required whitespace separator
									\K                                          # keep the text matched so far, out of the overall match
									[^\r\n]*$                                   # whatever, until end-of-line
								|
									(?'TAG'(?-i:Function|PageEx|Section))
									\h+                                         # required whitespace separator
									(?-i:/o\h+)?                                # optional switch
									\K                                          # keep the text matched so far, out of the overall match
									(?s:
										.*?                                     # whatever,
										(?=                                     # up till...
											^\k'INDENT'                         # ...equal indent at start-of-line for...
											\k'TAG'End\b                        # ...matching close indicator
										)
									)
								|
									\x24\x7B                                    # start-of-open-element indicator
									(?'ID'[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*)
									\x7D                                        # end-of-open-element indicator
									\h+                                         # required whitespace separator
									(?-i:/o\h+)?                                # optional switch
									\K                                          # keep the text matched so far, out of the overall match
									(?s:
										.*?                                     # whatever,
										(?=                                     # up till...
											^\k'INDENT'                         # ...equal indent at start-of-line for...
											\x24\x7B\k'ID'End\x7D               # ...matching close indicator
										)
									)
								)
							"
					>
						<functionName>
							<funcNameExpr expr="(?x)                            # Utilize inline comments (see `RegEx - Pattern Modifiers`)
									(?m)
									[^\r\n]+?                                   # whatever,
									(?=                                         # up till...
										\h*                                     # ...optional whitespace and...
										(?:
											\x2F\x2A                            # ...start of multi line comment or...
										|	[\x23;]                             # ...start of single line comment or...
										|	$                                   # ...end-of-line
										)
									)
								"
							/>
						</functionName>
					</function>
				</classRange>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?m)
							^(?'INDENT'\h*)                                     # optional leading whitespace at start-of-line
							(?:
								(?-i:!macro)
								\h+                                             # required whitespace separator
								\K                                              # keep the text matched so far, out of the overall match
								[^\r\n]*$                                       # whatever, until end-of-line
							|
								(?'TAG'(?-i:Function|PageEx|Section))
								\h+                                             # required whitespace separator
								(?-i:/o\h+)?                                    # optional switch
								\K                                              # keep the text matched so far, out of the overall match
								(?s:
									.*?                                         # whatever,
									(?=                                         # up till...
										^\k'INDENT'                             # ...equal indent at start-of-line for...
										\k'TAG'End\b                            # ...matching close indicator
									)
								)
							|
								\x24\x7B                                        # start-of-open-element indicator
								(?'ID'[A-Za-z_\x7F-\xFF][\w\x7F-\xFF]*)
								\x7D                                            # end-of-open-element indicator
								\h+                                             # required whitespace separator
								(?-i:/o\h+)?                                    # optional switch
								\K                                              # keep the text matched so far, out of the overall match
								(?s:
									.*?                                         # whatever,
									(?=                                         # up till...
										^\k'INDENT'                             # ...equal indent at start-of-line for...
										\x24\x7B\k'ID'End\x7D                   # ...matching close indicator
									)
								)
							)
						"
				>
					<functionName>
						<nameExpr expr="(?x)                                    # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?m)
								[^\r\n]+?                                       # whatever,
								(?=                                             # up till...
									\h*                                         # ...optional whitespace and...
									(?:
										\x2F\x2A                                # ...start of multi line comment or...
									|	[\x23;]                                 # ...start of single line comment or...
									|	$                                       # ...end-of-line
									)
								)
							"
						/>
					</functionName>
				</function>
			</parser>

			<!-- ==================================================== [ Assembly ] -->

			<parser
				displayName="Assembly"
				id         ="assembly_subroutine"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?m-s:;.*$)                                     # Single Line Comment
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?m)^\h*                                            # optional leading whitespace
							\K                                                  # keep the text matched so far, out of the overall match
							[A-Za-z_$][\w$]*                                    # valid character combination for labels
							(?=:)                                               # up till the colon
						"
				/>
			</parser>

			<!-- ======================================================== [ Ruby ] -->

			<parser
				displayName="Ruby"
				id         ="ruby_syntax"
			>
				<!-- within a class-->
				<classRange
					mainExpr    ="(?&lt;=^class\x20).*?(?=\n\S|\Z)"
				>
					<className>
						<nameExpr expr="\w+" />
					</className>
					<function
						mainExpr="^\s*def\s+\w+"
					>
						<functionName>
							<funcNameExpr expr="(?&lt;=def\s)\w+" />
						</functionName>
					</function>
				</classRange>
				<!-- without class-->
				<function
					mainExpr="^\s*def\s+\w+"
				>
					<functionName>
						<nameExpr expr="(?&lt;=def\s)\w+" />
					</functionName>
				</function>
			</parser>

			<!-- ===================================================== [ AutoIt3 ] -->

			<!--
			|   Based on:
			|       https://sourceforge.net/p/notepad-plus/discussion/331753/thread/5d9bb881/#e86e
			\-->
			<parser
				displayName="AutoIt3"
				id         ="autoit3_function"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?is:\x23cs.*?\x23ce)                           # Multi Line Comment
							|	(?m-s:^\h*;.*?$)                                # Single Line Comment
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?m)^\h*                                            # optional leading whitespace
							(?i:FUNC\s+)                                        # start-of-function indicator
							\K                                                  # keep the text matched so far, out of the overall match
							[A-Za-z_]\w*                                        # valid character combination for identifiers
							\s*\([^()]*?\)                                      # parentheses required, parameters optional
						"
				>
					<!-- comment out the following node to display the function with its parameters -->
					<functionName>
						<nameExpr expr="[A-Za-z_]\w*" />
					</functionName>
				</function>
			</parser>

			<!-- ================================================== [ Inno Setup ] -->

			<parser
				displayName="Inno Setup"
				id         ="innosetup_syntax"
			>
				<classRange
					mainExpr    ="(?x)                                          # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?ms)
							(?'SECTION_HEADER'
								^                                               # header starts at beginning of a line
								\[                                              # start of section header
								(?-i:Code)                                      # `Code` section name
								]                                               # end of section header
							)
							.*?                                                 # whatever, up till...
							(?=                                                 # ...next valid section header or...
								^                                               #    +-- header starts at beginning of a line
								\[                                              #    +-- start-of-header indicator
								(?-i:
									Components|(?:Custom)?Messages
								|	Dirs
								|	Files
								|	I(?:cons|nstallDelete)
								|	Languages
								|	R(?:egistry|un)
								|	Setup
								|	T(?:asks|ypes)
								|	Uninstall(?:Delete|Run)
								)                                               #    +-- valid section name
								]                                               #    \-- end-of-header indicator
							|	\Z                                              # ...end-of-file
							)
						"
				>
					<className>
						<nameExpr expr="^\[\K[^\h\]]+(?=])" />
					</className>
					<function
						mainExpr="(?x)                                          # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?m-s)^\h*                                      # optional leading whitespace
								(?i:FUNCTION\h+)
								(?'VALID_ID'
									[A-Za-z_]\w*
								)
								\s*\(                                           # start-of-parameter-list indicator
								[^()]*                                          # parameter list
								\s*\)                                           # end-of-parameter-list indicator
								\s*:                                            # type indicator
								\s*[A-Za-z_]\w*                                 # type identifier
								\s*;                                            # end-of-statement indicator
							"
					>
						<functionName>
							<funcNameExpr expr="(?i:FUNCTION\h+)\K[A-Za-z_]\w*\s*\([^()]*\)" />
							<!-- comment out the following node to display the method with its parameters -->
							<funcNameExpr expr="[A-Za-z_]\w*" />
						</functionName>
					</function>
				</classRange>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?ms)
							(?'SECTION_HEADER'
								^                                               # header starts at beginning of a line
								\[                                              # start-of-header indicator
								(?-i:
									Components|(?:Custom)?Messages
								|	Dirs
								|	Files
								|	I(?:cons|nstallDelete)
								|	Languages
								|	R(?:egistry|un)
								|	Setup
								|	T(?:asks|ypes)
								|	Uninstall(?:Delete|Run)
								)                                               # valid section name
								]                                               # end-of-header indicator
							)
							.*?                                                 # whatever, up till...
							(?=
								(?&amp;SECTION_HEADER)                          # ...next valid section header,...
							|	^\[(?-i:Code)]                                  # ...`Code` section header or...
							|	\Z                                              # ...end-of-file
							)
						"
				>
					<functionName>
						<nameExpr expr="^\[\K[^\]]+(?=])" />
					</functionName>
				</function>
			</parser>

			<!-- ================================================== [ PowerShell ] -->

			<parser
				displayName="PowerShell"
				id         ="powershell_function"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?s:\x3C\x23(?:[^\x23]|\x23[^\x3E])*\x23\x3E)   # Multi Line Comment
							|	(?m-s:\x23.*$)                                  # Single Line Comment
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							\b
							(?:function|filter)
							\s+
							(?:
								[A-Za-z_]\w*
								:
							)?
							[A-Za-z_][\w\-]*
							\s*
							[({]
						"
				>
					<functionName>
						<nameExpr expr="[A-Za-z_][\w\-]*(?=\s*[({])" />
					</functionName>
					<className>
						<nameExpr expr="[A-Za-z_]\w*(?=:)" />
					</className>
				</function>
			</parser>

			<!-- ================================================ [ J(ava)Script ] -->

			<parser
				displayName="JavaScript"
				id         ="javascript_function"
				commentExpr="(?s:/\*.*?\*/)|(?m-s://.*?$)"
			>
				<function
					mainExpr="((^|\s+|[;\}\.])([A-Za-z_$][\w$]*\.)*[A-Za-z_$][\w$]*\s*[=:]|^|[\s;\}]+)\s*function(\s+[A-Za-z_$][\w$]*)?\s*\([^\)\(]*\)[\n\s]*\{"
				>
					<functionName>
						<nameExpr expr="[A-Za-z_$][\w$]*\s*[=:]|[A-Za-z_$][\w$]*\s*\(" />
						<nameExpr expr="[A-Za-z_$][\w$]*" />
					</functionName>
					<className>
						<nameExpr expr="([A-Za-z_$][\w$]*\.)*[A-Za-z_$][\w$]*\." />
						<nameExpr expr="([A-Za-z_$][\w$]*\.)*[A-Za-z_$][\w$]*" />
					</className>
				</function>
			</parser>

			<!-- ========================================================= [ KRL ] -->
			<!-- KRL - KUKA Robot Language                                         -->

			<!--
			|   https://notepad-plus-plus.org/community/topic/12264/function-list-for-new-language
			\-->
			<parser
				displayName="KRL"
				id         ="krl_function"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?m-s:;.*$)                                     # Single Line Comment
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?i:
								(?:GLOBAL\h+)?
								DEF                                             # start-of-procedure indicator, possible extended to...
								(?:
									FCT                                         # ...start-of-function indicator
									\h+
									(?:BOOL|CHAR|INT|REAL|(?&amp;VALID_ID))     # returning a primitive type or a user-defined-type...
									(?:                                         # ...optionally as an array
										\h*\[
										\h*(?:\d+|\x27(?:H[0-9A-Fa-f]+|B[01]+)\x27)?
										\h*\]
									)?
								)?
							)
							\h+
							\K                                                  # keep the text matched so far, out of the overall match
							(?'VALID_ID'                                        # valid identifier, use as subroutine
								\b(?!(?i:
									AN(?:D|IN|OUT)
								|	B(?:OOL|RAKE|_(?:AND|EXOR|NOT|OR))
								|	C(?:ASE|AST_(?:FROM|TO)|HAR|IRC(?:_REL)?|ON(?:ST|TINUE)|_(?:DIS|ORI|PTP|VEL))
								|	D(?:ECL|EF(?:AULT|DAT|FCT)|ELAY|O)
								|	E(?:LSE|ND(?:DAT|FCT|FOR|IF|LOOP|SWITCH|WHILE)?|NUM|X(?:IT|OR|T(?:FCT)?))
								|	F(?:ALSE|OR)
								|	G(?:LOBAL|OTO)
								|	HALT
								|	I(?:[FS]|MPORT|NT(?:ERRUPT)?)
								|	L(?:IN(?:_REL)?|OOP)
								|	M(?:AXI|INI)MUM
								|	NOT
								|	OR
								|	P(?:RIO|TP(?:_REL)?|UBLIC)
								|	RE(?:AL|PEAT|SUME|TURN)
								|	S(?:EC|IGNAL|TRUC|WITCH)
								|	T(?:HEN|O|RIGGER|RUE)
								|	UNTIL
								|	W(?:AIT|HEN|HILE)
								)\b)                                            # keywords, not to be used as identifier
								[$A-Za-z_\x7F-\xFF][$\w\x7F-\xFF]{0,23}         # valid character combination for identifiers
							)
							\h*\([^)]*\)
						"
				>
					<!-- comment out the following node to display the method with its parameters -->
					<functionName>
						<nameExpr expr="[$A-Za-z_\x7F-\xFF][$\w\x7F-\xFF]{0,23}" />
					</functionName>
				</function>
			</parser>

			<!-- =================================================== [ Sinumerik ] -->
			<!-- Sinumerik - Siemens Numeric Control                               -->

			<!--
			|   https://notepad-plus-plus.org/community/topic/12520/function-list-for-simatic
			|   20161113: Added `(?!\$PATH)` to get around restriction/bug of
			|             two characters required before comment.
			\-->
			<parser
				displayName="Sinumerik"
				id         ="sinumerik_function"
				commentExpr="(?m-s:;(?!\$PATH).*?$)"
			>
				<function
					mainExpr="(?m)^%_N_\K[A-Za-z_]\w*"
				/>
			</parser>

			<!-- ============================================== [ UniVerse BASIC ] -->

			<!--
			|   Based on:
			|       https://notepad-plus-plus.org/community/topic/12742/functionlist-different-results-with-different-line-endings
			\-->
			<parser
				displayName="UniVerse BASIC"
				id         ="universe_basic"
				commentExpr="(?x)                                               # Utilize inline comments (see `RegEx - Pattern Modifiers`)
								(?m-s:
									(?:^|;)                                     # at start-of-line or after end-of-statement
									\h*                                         # optional leading whitespace
									(?-i:REM\b|\x24\x2A|[\x21\x2A])             # Single Line Comment 1..4
									.*$                                         # whatever, until end-of-line
								)
							|	(?:\x22[^\x22\r\n]*\x22)                        # String Literal - Double Quoted
							|	(?:\x27[^\x27\r\n]*\x27)                        # String Literal - Single Quoted
							|	(?:\x5C[^\x5C\r\n]*\x5C)                        # String Literal - Backslash Quoted
							"
			>
				<function
					mainExpr="(?x)                                              # Utilize inline comments (see `RegEx - Pattern Modifiers`)
							(?m-i)^                                             # case-sensitive, NO leading whitespace
							(?:
								\d+\b(?=:?)                                     # completely numeric label, colon optional + discarded
							|	[A-Za-z_][\w.$%]*(?=:)                          # alphanumeric label, colon required + discarded
							)
						"
				/>
			</parser>
			
			<!-- ======================================================= [ BaanC ] -->
			
			<!-- ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
			|	Based on:
			|		https://notepad-plus-plus.org/community/topic/14494/functionlist-classrange-question
			|
			|	Note(s):
			|	1.	Boost::Regex 1.58-1.59 do not correctly handle quantifiers on subroutine calls
			|		therefore the additional non-capturing group i.e. "(?:(?&amp;COMMENT))?" instead
			|		of simply "(?&amp;COMMENT)?"
			\-->
			<parser
				displayName="BaanC Sections"
				id         ="baanc_section"
			>
				<classRange
					mainExpr="(?x)                                              # free-spacing (see `RegEx - Pattern Modifiers`)
							(?im)                                               # case-insensitive, ^ and $ match at line breaks
							(?(DEFINE)                                          # definition of sub-routines
								(?'SECTION'
									^\h*                                        # optional leading whitespace at start-of-line
									(?:                                         # known section names
										(?:after|before)\.(?:report\.\d+|\w+(?:\.\w+)*\.\d+)
									|	(?:field|zoom\.from)\.(?:all|other|\w+(?:\.\w+)*)
									|	(?:footer|group|header)\.\d+
									|	choice\.\w+(?:\.\w+)*
									|	detail\.\d+
									|	form\.(?:all|other|\d+)
									|	functions
									|	main\.table\.io
									):                                          # end-of-section-header indicator
								)
								(?'SECTION_EMPTY'
									^\h*                                        # optional leading whitespace at start-of-line
									(?:                                         # known `empty` section names
										after\.(?:form\.read|program|receive\.data|update\.db\.commit)
									|	before\.(?:(?:display|new)\.object|program)
									|	declaration
									|	on\.(?:display\.total\.line|error)
									):                                          # end-of-section-header indicator
								)
							)
							(?&amp;SECTION)                                     # section header
							(?s:.*?)                                            # whatever,
							(?=                                                 # ...up till
								\s*
								(?:
									(?&amp;SECTION)                             # ...next section header,
								|   (?&amp;SECTION_EMPTY)                       # ...next `empty` section header
								|   \Z                                          # ...or end-of-text
								)
							)
						"
				>
					<className>
						<nameExpr expr="^\h*\K\w+(?:\.\w+)*:" />
					</className>
					<function
						mainExpr="(?x)                                          # free-spacing (see `RegEx - Pattern Modifiers`)
								(?im)                                           # case-insensitive, ^ and $ match at line breaks
								(?(DEFINE)                                      # definition of sub-routines
									(?'COMMENT'
										\s*\x7C[^\r\n]*                         # trailing comment
										(?:                                     # optional subsequent comment
											(?:\r?\n|\n?\r)                     # - mandatory line-break
											\s*\x7C[^\r\n]*                     # - `trailing` comment
										)*
									)
								)
								^\h*                                            # optional leading whitespace at start-of-line
								(?:
									\K                                          # discard text matched so far
									(?:                                         # known sub-section names
										after\.(?:choice|d(?:elete|isplay)|f(?:ield|orm)|group|input|layout|re(?:ad|write)|skip\.(?:delete|(?:re)?write)|write|zoom)
									|	before\.(?:ch(?:ecks|oice)|d(?:elete|isplay)|f(?:ield|orm)|group|input|layout|print|re(?:ad|write)|write|zoom)
									|	check\.input
									|	domain\.error
									|	init\.(?:f(?:ield|orm)|group)
									|	on\.(?:choice|e(?:ntry|xit)|input)
									|	read\.view
									|	ref\.(?:display|input)
									|	selection\.filter
									|	when\.field\.changes
									):                                          # end-of-sub-section-header indicator
								|
									function                                    # keyword, start-of-function-header indicator
									(?:(?&amp;COMMENT))?                        # optional `embedded` comment
									(?:                                         # optional storage-class specifier
										\s+extern
										(?:(?&amp;COMMENT))?                    # ...with optional `embedded` comment
									)?
									(?:                                         # optional function type specifier
										\s+(?:
											boolean
										|	double
										|	long
										|	string
										|	void
										|	domain
											(?:(?&amp;COMMENT))?                # ...with optional `embedded` comment
											\s+\w+(?:\.\w+)*
										)
										(?:(?&amp;COMMENT))?                    # ...with optional `embedded` comment
									)?
									\s+
									\K                                          # discard text matched so far
									\w+(?:\.\w+)*                               # function identifier
									(?:(?&amp;COMMENT)(?:\r?\n|\n?\r))?         # optional `embedded` comment
									\s*\(                                       # start-of-parameter-list indicator
								)
							"
					>
						<functionName>
							<funcNameExpr expr="\w+(?:\.\w+)*(?:\h*:)?" />
						</functionName>
					</function>
				</classRange>
				<function
					mainExpr="(?x)                                              # free-spacing (see `RegEx - Pattern Modifiers`)
							(?im)                                               # case-insensitive, ^ and $ match at line breaks
							(?(DEFINE)                                          # definition of sub-routines
								(?'COMMENT'
									\s*\x7C[^\r\n]*                             # trailing comment
									(?:                                         # optional subsequent comment
										(?:\r?\n|\n?\r)                         # - mandatory line-break
										\s*\x7C[^\r\n]*                         # - `trailing` comment
									)*
								)
							)
							^\h*                                                # optional leading whitespace at start-of-line
							(?:
								\K                                              # discard text matched so far
								(?:                                             # known `empty` section names
									after\.(?:form\.read|program|receive\.data|update\.db\.commit)
								|	before\.(?:display\.object|new\.object|program)
								|	declaration
								|	on\.(?:display\.total\.line|error)
								):                                              # end-of-section-header indicator
							|
								function                                        # keyword, start-of-function-header indicator
								(?:(?&amp;COMMENT))?                            # optional `embedded` comment
								(?:                                             # optional storage-class specifier
									\s+extern
									(?:(?&amp;COMMENT))?                        # ...with optional `embedded` comment
								)?
								(?:                                             # optional function type specifier
									\s+(?:
										boolean
									|	double
									|	long
									|	string
									|	void
									|	domain
										(?:(?&amp;COMMENT))?                    # ...with optional `embedded` comment
										\s+\w+(?:\.\w+)*
									)
									(?:(?&amp;COMMENT))?                        # ...with optional `embedded` comment
								)?
								\s+
								\K                                              # discard text matched so far
								\w+(?:\.\w+)*                                   # function identifier
								(?:(?&amp;COMMENT)(?:\r?\n|\n?\r))?             # optional `embedded` comment
								\s*\(                                           # start-of-parameter-list indicator
							)
						"
				>
					<functionName>
						<nameExpr expr="\w+(?:\.\w+)*(?:\h*:)?" />
					</functionName>
				</function>
			</parser>

			<!-- ================================================================= -->
		</parsers>
	</functionList>
</NotepadPlus>
